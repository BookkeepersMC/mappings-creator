package mappings.plugin.plugin;

import org.gradle.api.Action;
import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.file.Directory;
import org.gradle.api.plugins.JavaPlugin;
import org.gradle.api.plugins.PluginContainer;
import org.gradle.api.tasks.SourceTask;
import org.gradle.api.tasks.TaskContainer;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.api.tasks.javadoc.Javadoc;
import org.jetbrains.annotations.NotNull;
import mappings.plugin.extension.ProcessMappingsExtension;
import mappings.plugin.extension.MappingsExtension;
import mappings.plugin.constants.Groups;
import mappings.plugin.decompile.javadoc.MappingsJavadocProvider;
import mappings.plugin.plugin.abstraction.DefaultExtensionedMappingsProjectPlugin;
import mappings.plugin.task.build.AddProposedMappingsTask;
import mappings.plugin.task.build.EraseByteCodeTask;
import mappings.plugin.task.build.GenFakeSourceTask;
import mappings.plugin.task.build.MergeTinyV2Task;
import mappings.plugin.task.decompile.DecompileVineflowerTask;
import mappings.plugin.task.jarmapping.MapNamedJarTask;
import mappings.plugin.task.setup.DownloadMinecraftLibrariesTask;
import mappings.plugin.task.setup.JavadocJarTask;
import mappings.plugin.task.setup.SourcesJarTask;

/**
 * {@linkplain TaskContainer#register Registers} tasks that
 * process jars and mappings output by tasks from other plugins.
 * <p>
 * Applies:
 * <ul>
 *     <li> {@link JavaPlugin}
 *     <li> {@link MinecraftJarsPlugin}
 *     <li> {@link MapMinecraftJarsPlugin}
 *     <li> {@link MapV2Plugin}
 * </ul>
 * Additionally:
 * <ul>
 *     <li> creates the {@value JAVADOC_CLASSPATH_CONFIGURATION_NAME} {@link Configuration}
 *     <li> {@linkplain TaskProvider#configure(Action) configures} the {@value JavaPlugin#JAVADOC_TASK_NAME} task:
 *          <ul>
 *              <li> adds the contents of the {@value GenFakeSourceTask#GEN_FAKE_SOURCE_TASK_NAME} task's
 *                   {@link GenFakeSourceTask#getOutput() output} as a {@link SourceTask#source(Object...) source}
 *              <li> {@linkplain Javadoc#setClasspath sets its classpath} to contain:
 *                   <ul>
 *                       <li> the {@value JAVADOC_CLASSPATH_CONFIGURATION_NAME} {@link Configuration}
 *                       <li> the contents of the
 *                            {@value DownloadMinecraftLibrariesTask#DOWNLOAD_MINECRAFT_LIBRARIES_TASK_NAME} task's
 *                            {@link DownloadMinecraftLibrariesTask#getLibrariesDir() librariesDir}
 *                       <li> the {@value MapNamedJarTask#MAP_NAMED_JAR_TASK_NAME} task's
 *                            {@link MapNamedJarTask#getOutputJar() outputJar}
 *                   </ul>
 *          </ul>
 * </ul>
 */
public abstract class ProcessMappingsPlugin extends DefaultExtensionedMappingsProjectPlugin<ProcessMappingsExtension> {
    public static final String JAVADOC_CLASSPATH_CONFIGURATION_NAME = "javadocClasspath";

    @Override
    protected ProcessMappingsExtension applyImpl(@NotNull Project project) {
        final Configuration javadocClasspath = project.getConfigurations().create(JAVADOC_CLASSPATH_CONFIGURATION_NAME);

        // apply required plugins and save their registered objects
        final PluginContainer plugins = project.getPlugins();

        // adds javadoc task
        plugins.apply(JavaPlugin.class);

        final MappingsExtension quiltExt = plugins.apply(MappingsBasePlugin.class).getExt();

        final MinecraftJarsPlugin.Tasks minecraftJarsTasks =
            plugins.apply(MinecraftJarsPlugin.class).getExt().getTasks();
        final TaskProvider<DownloadMinecraftLibrariesTask> downloadMinecraftLibraries =
            minecraftJarsTasks.downloadMinecraftLibraries();

        final MapMinecraftJarsPlugin.Tasks mapMinecraftJarsTasks =
            plugins.apply(MapMinecraftJarsPlugin.class).getExt().getTasks();
        final TaskProvider<AddProposedMappingsTask> insertAutoGeneratedMappings =
            mapMinecraftJarsTasks.insertAutoGeneratedMappings();

        final MapV2Plugin.Tasks mappingsV2Tasks =
            plugins.apply(MapV2Plugin.class).getExt().getTasks();
        final TaskProvider<MergeTinyV2Task> mergeTinyV2 =
            mappingsV2Tasks.mergeTinyV2();
        final var mapNamedJar =
            mappingsV2Tasks.mapNamedJar();

        // register this plugin's tasks
        final TaskContainer tasks = project.getTasks();

        final var eraseBytecode = tasks.register(
            EraseByteCodeTask.ERASE_BYTECODE_TASK_NAME,
            EraseByteCodeTask.class,
            task -> {
                task.getJarFile().convention(mapNamedJar.flatMap(MapNamedJarTask::getOutputJar));

                task.getOutput().convention(this.getTempDir().map(dir -> dir.dir("erased-classes")));
            }
        );

        final var genFakeSource = tasks.register(
            GenFakeSourceTask.GEN_FAKE_SOURCE_TASK_NAME,
            GenFakeSourceTask.class,
            task -> {
                task.getSources().from(eraseBytecode.flatMap(EraseByteCodeTask::getOutput));

                task.getLibraries().from(
                    downloadMinecraftLibraries.flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                );

                task.getDefaultJavadocSource().convention(
                    MappingsJavadocProvider.provideNamed(mergeTinyV2.flatMap(MergeTinyV2Task::getOutputMappings))
                );

                task.getOutput().convention(this.getTempDir().map(dir -> dir.dir("fakeSource")));
            }
        );

        final var decompileVineflower = tasks.register(
            DecompileVineflowerTask.DECOMPILE_VINEFLOWER_TASK_NAME,
            DecompileVineflowerTask.class,
            task -> {
                task.getSources().from(mapNamedJar.flatMap(MapNamedJarTask::getOutputJar));

                task.getLibraries().from(
                    downloadMinecraftLibraries.flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                );

                task.getDefaultJavadocSource().convention(MappingsJavadocProvider.provideNamed(
                    insertAutoGeneratedMappings.flatMap(AddProposedMappingsTask::getOutputMappings)
                ));

                // TODO LATER move this to build/ once generate-diff.yml uses generateDiff
                task.getOutput().convention(this.getProjectDir().dir("namedSrc"));
            }
        );

        // sources are added in build.gradle because they're from a project source set
        tasks.register(SourcesJarTask.SOURCES_JAR_TASK_NAME, SourcesJarTask.class);

        final var javadoc = tasks.named(JavaPlugin.JAVADOC_TASK_NAME, Javadoc.class, task -> {
            task.setGroup(Groups.JAVADOC_GENERATION);

            task.source(genFakeSource.flatMap(GenFakeSourceTask::getOutput).map(Directory::getAsFileTree));

            task.setClasspath(
                this.getProjectDir().files(
                    javadocClasspath,
                    downloadMinecraftLibraries
                        .flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                        .map(Directory::getAsFileTree),
                    mapNamedJar.flatMap(MapNamedJarTask::getOutputJar)
                )
            );
        });

        tasks.register(JavadocJarTask.JAVADOC_JAR_TASK_NAME, JavadocJarTask.class, task -> {
            task.getArchiveVersion().convention(quiltExt.getMappingsVersion());

            task.from(javadoc.map(Javadoc::getDestinationDir));
        });

        return project.getExtensions().create(
            ProcessMappingsExtension.NAME, ProcessMappingsExtension.class,
            new Tasks(decompileVineflower)
        );
    }

    public record Tasks(TaskProvider<DecompileVineflowerTask> decompileVineflower) { }
}
