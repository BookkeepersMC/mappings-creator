package mappings.plugin;

import daomephsta.unpick.constantmappers.datadriven.parser.UnpickSyntaxException;
import net.fabricmc.mappingio.tree.MappingTree;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.condition.EnabledIf;
import org.junit.jupiter.api.io.CleanupMode;
import org.junit.jupiter.api.io.TempDir;
import org.quiltmc.enigma.api.EnigmaProfile;
import mappings.plugin.constants.Namespaces;
import mappings.plugin.task.build.AddProposedMappingsTask;
import mappings.plugin.task.build.BuildMappingsTinyTask;
import mappings.plugin.task.build.InvertPerVersionMappingsTask;
import mappings.plugin.task.build.MergeIntermediaryTask;
import mappings.plugin.task.build.MergeTinyTask;
import mappings.plugin.task.build.MergeTinyV2Task;
import mappings.plugin.task.build.RemoveIntermediaryTask;
import mappings.plugin.task.unpick.CombineUnpickDefinitionsTask;
import mappings.plugin.task.unpick.RemapUnpickDefinitionsTask;
import mappings.plugin.util.JarRemapper;
import mappings.plugin.util.UnpickFile;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static mappings.plugin.TestUtil.getClassOrThrow;
import static mappings.plugin.TestUtil.getMethodOrThrow;
import static mappings.plugin.util.MappingAssertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@EnabledIf("obfJarExists")
public class TasksTest {
    private static final Path OBF_JAR = Path.of("build/libs/test-input-obf.jar").toAbsolutePath();

    @TempDir(
        // DEBUG
        // cleanup = CleanupMode.NEVER
        cleanup = CleanupMode.ON_SUCCESS
    )
    private static Path testProjectDir;
    private static Path mappingsDir;
    private static Path profilePath;
    private static Path unpickDefinitions;
    private static Path brokenUnpickDefinitions;

    private static Path perVersionMappingsJar;
    private static Path outputsDir;
    private static Path perVersionMappings;
    private static Path buildMappingsTinyOutput;
    private static Path invertedPerVersionMappings;
    private static Path insertAutoGeneratedMappingsOutput;
    private static Path mergeTinyV2Output;
    private static Path namedJar;
    private static Path combineUnpickDefinitionsOutput;
    private static Path intermediaryMappings;
    private static Path mergeIntermediaryOutput;

    private static Path getResource(String name) throws URISyntaxException {
        final URL resource = Objects.requireNonNull(
            TasksTest.class.getResource(name),
            "Missing resource: " + name
        );

        return Path.of(resource.toURI());
    }

    public static boolean obfJarExists() {
        return Files.isRegularFile(OBF_JAR);
    }

    @BeforeAll
    public static void setup() throws Exception {
        // DEBUG
        // System.out.println("Setting up test project at " + testProjectDir.toAbsolutePath());
        final Path source = getResource("/testProject");

        try (Stream<Path> files = Files.walk(source)) {
            files.forEach(p -> {
                final Path relative = source.relativize(p);
                try {
                    if (!Files.isDirectory(relative)) {
                        Files.copy(p, testProjectDir.resolve(relative));
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Failed to copy " + relative, e);
                }
            });
        }

        mappingsDir = testProjectDir.resolve("mappings/");
        profilePath = testProjectDir.resolve("enigma_profile.json");
        unpickDefinitions = testProjectDir.resolve("unpick-definitions/");
        brokenUnpickDefinitions = testProjectDir.resolve("broken-unpick-definitions/");

        perVersionMappings = getResource("/test-intermediate.tiny");
        perVersionMappingsJar = testProjectDir.resolve("test-hashed.jar");
        outputsDir = testProjectDir.resolve("outputs/");
        Files.createDirectories(outputsDir);

        // Map the test input jar
        JarRemapper.mapJar(
            perVersionMappingsJar, OBF_JAR, perVersionMappings, new Path[0],
            "official", Namespaces.INTERMEDIATE, null
        );

        intermediaryMappings = getResource("/test-intermediate-alt.tiny");
    }

    @Test
    @Order(1)
    public void testBuildMappingsTiny() throws Exception {
        final Path output = outputsDir.resolve("built-mappings.tiny");
        buildMappingsTinyOutput = output;
        BuildMappingsTinyTask.buildMappingsTiny(
            perVersionMappingsJar,
            mappingsDir,
            output
        );

        final MappingTree tree = TestUtil.readTinyV2(output);
        assertSrcNamespace(Namespaces.INTERMEDIATE, tree);
        assertDstNamespace("named", tree, 0);
        assertMapping("com/example/AClass", tree.getClass("com/example/u/C_001"), "named");
    }

    @Test
    @Order(2)
    public void testInvertPerVersionMappings() throws Exception {
        final Path output = outputsDir.resolve("test-intermediate-inverted.tiny");
        invertedPerVersionMappings = output;
        InvertPerVersionMappingsTask.invertMappings(perVersionMappings.toFile(), output.toFile());

        final MappingTree inputTree = TestUtil.readTinyV2(perVersionMappings);
        final MappingTree outputTree = TestUtil.readTinyV2(output);
        assertDstNamespace(inputTree.getSrcNamespace(), outputTree, 0);
        assertSrcNamespace(inputTree.getDstNamespaces().get(0), outputTree);
        final String className = "com/example/u/C_001";
        final MappingTree.ClassMapping C001Class = getClassOrThrow(inputTree, className, 0);
        assertMapping(C001Class.getName(-1), outputTree.getClass(className), 0);
    }

    private void testMergedTree(MappingTree tree, String intermediateNamespace) {
        assertSrcNamespace("official", tree);
        assertDstNamespaces(List.of(intermediateNamespace, "named"), tree);
        assertNotNull(tree.getClass("com/example/AClass", 1));
        assertMappingNotEmpty(tree.getClass("b"), "named");
        assertMappingNotEmpty(tree.getClass("c"), 0); // Should always have a per-version name
        assertMappingNotEmpty(tree.getClass("c$a"), 0);
        // Unmapped methods should not have a `named` name
        final MappingTree.MethodMapping method = getMethodOrThrow(tree, "c$a", "a", "()[Lc$a;");
        assertMappingEmpty(method, "named");

        assertNotNull(tree.getClass("h"));
        // Unobfuscated methods should either not have a mapping,
        // or be remapped to the original name in the named namespace
        final MappingTree.MethodMapping unobfuscatedMethod = tree.getMethod("h", "get", "(I)I");
        if (unobfuscatedMethod != null) {
            assertMapping("get", unobfuscatedMethod, "named");
        }
    }

    @Test
    @Order(3)
    public void testMergeTiny() throws Exception {
        final Path output = outputsDir.resolve("merged.tiny");
        MergeTinyTask.mergeMappings(buildMappingsTinyOutput, invertedPerVersionMappings, output);

        final MappingTree tree = TestUtil.readTinyV2(output);
        this.testMergedTree(tree, Namespaces.INTERMEDIATE);
    }

    @Test
    @Order(4)
    public void testInsertAutoGeneratedMappings() throws Exception {
        final Path output = outputsDir.resolve("insertAutoGeneratedMappings.tiny");
        final Path preprocessedMappings = outputsDir.resolve("insertAutoGeneratedMappings-preprocessed.tiny");
        final Path processedMappings = outputsDir.resolve("insertAutoGeneratedMappings-processed.tiny");
        insertAutoGeneratedMappingsOutput = output;
        AddProposedMappingsTask.addProposedMappings(
            buildMappingsTinyOutput, output,
            preprocessedMappings, processedMappings,
            perVersionMappingsJar,
            EnigmaProfile.read(profilePath)
        );

        final MappingTree tree = TestUtil.readTinyV2(output);
        final MappingTree inputTree = TestUtil.readTinyV2(buildMappingsTinyOutput);
        assertSrcNamespace(inputTree.getSrcNamespace(), tree);
        assertDstNamespaces(inputTree.getDstNamespaces(), tree);

        assertMapping("com/example/AClass", tree.getClass("com/example/u/C_001"), "named");
        assertMapping("com/example/BEnum", tree.getClass("com/example/u/C_002"), "named");

        // f_004 FIRST
        final MappingTree.FieldMapping insertedField =
            tree.getField("com/example/u/C_002", "f_004", "Lcom/example/u/C_002;");
        assertMapping("FIRST", insertedField, "named");
        final MappingTree.FieldMapping prevMapping =
            inputTree.getField("com/example/u/C_002", "f_004", "Lcom/example/u/C_002;");
        assertNull(prevMapping);

        // f_011 NORMAL
        final MappingTree.FieldMapping insertedField2 =
            tree.getField("com/example/u/C_003$C_004", "f_011", "Lcom/example/u/C_003$C_004;");
        assertMapping("NORMAL", insertedField2, "named");

        // f_015 left
        final MappingTree.FieldMapping insertedField3 =
            tree.getField("com/example/u/C_005", "f_015", "Ljava/lang/Object;");
        assertMapping("left", insertedField3, "named");
        // m_013 right
        final MappingTree.MethodMapping insertedMethod =
            tree.getMethod("com/example/u/C_005", "m_013", "()Ljava/lang/Object;");
        assertMapping("right", insertedMethod, "named");

        final MappingTree.MethodMapping insertedMethod2 =
            tree.getMethod("com/example/u/C_005", "equals", "(Ljava/lang/Object;)Z");
        assertNotNull(insertedMethod2);
        assertMapping("o", insertedMethod2.getArg(-1, 1, null), "named");

        final MappingTree.MethodMapping insertedMethod3 =
            tree.getMethod("com/example/u/C_005", "<init>", "(Ljava/lang/Object;Ljava/lang/Object;)V");
        assertNotNull(insertedMethod3);
        assertMapping("left", insertedMethod3.getArg(-1, 1, null), "named");
        assertMapping("right", insertedMethod3.getArg(-1, 2, null), "named");

        // Check inner class mappings
        assertMapping("com/example/LClass", tree.getClass("com/example/u/C_017"), "named");
        assertMapping("com/example/LClass$C_018", tree.getClass("com/example/u/C_017$C_018"), "named");
        assertMapping("com/example/LClass$C_019", tree.getClass("com/example/u/C_017$C_019"), "named");
        assertMapping("com/example/LClass$C_020", tree.getClass("com/example/u/C_017$C_020"), "named");

        // The tree for C_024 is completely unmapped,
        // but it has proposed names which require the class names to be present
        assertMapping("com/example/u/C_024", tree.getClass("com/example/u/C_024"), "named");
        assertMapping("com/example/u/C_024$C_025", tree.getClass("com/example/u/C_024$C_025"), "named");
        assertMapping("com/example/u/C_024$C_026", tree.getClass("com/example/u/C_024$C_026"), "named");
        assertMapping("com/example/u/C_024$C_027", tree.getClass("com/example/u/C_024$C_027"), "named");
        assertMapping("com/example/u/C_024$C_027$C_028", tree.getClass("com/example/u/C_024$C_027$C_028"), "named");
        assertMapping("com/example/u/C_024$C_027$C_029", tree.getClass("com/example/u/C_024$C_027$C_029"), "named");
    }

    @Test
    @Order(5)
    public void testMergeTinyV2() throws Exception {
        final Path output = outputsDir.resolve("merged-v2.tiny");
        mergeTinyV2Output = output;
        MergeTinyV2Task.mergeMappings(insertAutoGeneratedMappingsOutput, invertedPerVersionMappings, output);

        final MappingTree tree = TestUtil.readTinyV2(output);
        this.testMergedTree(tree, Namespaces.INTERMEDIATE);
        // com/example/u/C_002 f_004 FIRST
        assertMapping("FIRST", tree.getField("b", "a", "Lb;"), "named");
        // com/example/u/C_003$C_004 f_011 NORMAL
        assertMapping("NORMAL", tree.getField("c$a", "a", "Lc$a;"), "named");
    }

    private void mapNamedJar() {
        if (namedJar != null) {
            return;
        }

        namedJar = testProjectDir.resolve("test-named.jar");
        JarRemapper.mapJar(
            namedJar, perVersionMappingsJar, mergeTinyV2Output, new Path[0],
            Namespaces.INTERMEDIATE, "named", null
        );
    }

    @Test
    @Order(6)
    public void testCombineUnpickDefinitions() throws Exception {
        final Path output = outputsDir.resolve("combined-definitions.unpick");
        combineUnpickDefinitionsOutput = output;
        final File[] unpickDefinitionsContents = Objects.requireNonNull(
            unpickDefinitions.toFile().listFiles(),
            "Error accessing unpickDefinitions"
        );
        final Collection<File> input = List.of(unpickDefinitionsContents);
        CombineUnpickDefinitionsTask.combineUnpickDefinitions(input, output);

        this.mapNamedJar();
        final UnpickFile file = TestUtil.readUnpickFile(output, namedJar);
        assertTrue(file.containsGroup("e_flags"));
        assertTrue(file.isFlagGroup("e_flags"));
        assertEquals("e_flags", file.getParameterConstantGroup("com/example/EClass", "m1", "(I)V", 0));

        assertTrue(file.containsGroup("f_flags"));
        assertFalse(file.isSimpleConstantGroup("f_flags"));
        assertEquals(
            "f_flags",
            file.getParameterConstantGroup("com/example/FEnum", "<init>", "(Ljava/lang/String;II)V", 0)
        );

        assertTrue(file.containsGroup("g_type"));
        assertTrue(file.isSimpleConstantGroup("g_type"));
        assertEquals(
            "g_type",
            file.getParameterConstantGroup("com/example/GClass", "fromType", "(I)Ljava/lang/String;", 0)
        );
        assertEquals("g_type", file.getReturnConstantGroup("com/example/GClass", "toType", "(Ljava/lang/String;)I"));
    }

    @Test
    public void testCombineBrokenUnpickDefinitions() {
        final Path output = outputsDir.resolve("broken-combined-definitions.unpick");
        final File[] brokenUnpickDefinitionsContents = Objects.requireNonNull(
            brokenUnpickDefinitions.toFile().listFiles(),
            "Error accessing brokenUnpickDefinitions"
        );
        final Collection<File> input = List.of(brokenUnpickDefinitionsContents);
        assertThrows(
            UnpickSyntaxException.class,
            () -> CombineUnpickDefinitionsTask.combineUnpickDefinitions(input, output)
        );
    }

    @Test
    @Order(7)
    public void testRemapUnpickDefinitions() throws Exception {
        final Path output = outputsDir.resolve("remapped-definitions.unpick");
        RemapUnpickDefinitionsTask.remapUnpickDefinitions(combineUnpickDefinitionsOutput, mergeTinyV2Output, output);

        final UnpickFile file = TestUtil.readUnpickFile(output, perVersionMappingsJar);
        assertTrue(file.containsGroup("e_flags"));
        assertTrue(file.isFlagGroup("e_flags"));
        assertEquals("e_flags", file.getParameterConstantGroup("com/example/u/C_006", "m_014", "(I)V", 0));

        assertTrue(file.containsGroup("f_flags"));
        assertFalse(file.isSimpleConstantGroup("f_flags"));
        assertEquals(
            "f_flags",
            file.getParameterConstantGroup("com/example/u/C_007", "<init>", "(Ljava/lang/String;II)V", 0)
        );

        assertTrue(file.containsGroup("g_type"));
        assertTrue(file.isSimpleConstantGroup("g_type"));
        assertEquals(
            "g_type",
            file.getParameterConstantGroup("com/example/u/C_008", "m_023", "(I)Ljava/lang/String;", 0)
        );
        assertEquals(
            "g_type",
            file.getReturnConstantGroup("com/example/u/C_008", "m_024", "(Ljava/lang/String;)I")
        );
    }

    @Test
    @Order(8)
    public void testMergeIntermediary() throws Exception {
        final Path output = outputsDir.resolve("merged-intermediary.tiny");
        mergeIntermediaryOutput = output;
        MergeIntermediaryTask.mergeMappings(intermediaryMappings, mergeTinyV2Output, output);

        final MappingTree tree = TestUtil.readTinyV2(output);
        assertSrcNamespace("official", tree);
        assertDstNamespace("intermediary", tree, 0);
        assertDstNamespace("named", tree, 1);
        this.testMergedTree(tree, "intermediary");

        // Unobfuscated class
        final MappingTree.ClassMapping keep = getClassOrThrow(tree, "mappings/plugin/input/Keep");
        assertMapping(keep.getName("official"), keep, "intermediary");
        assertMappingEmpty(keep, "named");

        final MappingTree.ClassMapping keep1 = getClassOrThrow(tree, "mappings/plugin/input/Keep$1");
        assertMappingEmpty(keep1, "named");
        // Some classes don't have intermediary names, for some reason
        // If a class doesn't have an intermediary name, give it a named one instead
        final MappingTree.ClassMapping keep2 = getClassOrThrow(tree, "mappings/plugin/input/Keep$2");
        assertMappingEmpty(keep2, "intermediary");
        assertMapping(keep2.getName("official"), keep2, "named");

        // k has an inner named class
        final MappingTree.ClassMapping kClass = tree.getClass("k");
        assertMapping("com/example/class_012", kClass, "intermediary");
        // There's no way to fix this as far as I can tell,
        // since inner classes need their parents to have a matching name in the same namespaces
        // i.e. `a/b/c$d -> com/example/c_01$c_02 -> com/example/c_01$inner` would need
        // `a/b/c -> com/example/c_01 -> com/example/c_01`
        assertMapping("com/example/u/C_012", kClass, "named");
        final MappingTree.ClassMapping kInnerClass = tree.getClass("k$a");
        assertMapping("com/example/class_012$class_013", kInnerClass, "intermediary");
        assertMapping("com/example/u/C_012$AInner", kInnerClass, "named");
        // This class is unmapped, but it still gets a name from its parent
        final MappingTree.ClassMapping kInnerInnerClass = tree.getClass("k$a$a");
        assertMapping("com/example/class_012$class_013$class_014", kInnerInnerClass, "intermediary");
        assertMapping("com/example/u/C_012$AInner$C_014", kInnerInnerClass, "named");

        // These entries have inner data, but they shouldn't have names themselves
        // (removed by UnmappedNameRemoverVisitor)
        final MappingTree.FieldMapping f032 =
            TestUtil.getFieldOrThrow(tree, "k", "a", "Ljava/lang/String;");
        assertComment("f1", f032);
        assertMappingEmpty(f032, "named");
        final MappingTree.MethodMapping m029 =
            TestUtil.getMethodOrThrow(tree, "k", "a", "(Ljava/lang/String;)V");
        assertMapping("s", m029.getArg(-1, 1, null), "named");
        assertMappingEmpty(m029, "named");
        final MappingTree.MethodMapping m030 = getMethodOrThrow(tree, "k", "a", "()I");
        assertComment("m2", m030);
        assertMappingEmpty(m030, "named");
        final MappingTree.MethodMapping m031 =
            getMethodOrThrow(tree, "k$a", "a", "(Ljava/lang/String;)I");
        assertComment("m3", m031);
        assertMappingEmpty(m031, "named");
        assertMapping("s", m031.getArg(-1, 1, null), "named");
    }

    @Test
    @Order(9)
    public void testRemoveIntermediary() throws Exception {
        final Path output = outputsDir.resolve("mappings-intermediary.tiny");
        RemoveIntermediaryTask.removeIntermediary(mergeIntermediaryOutput, output);

        final MappingTree tree = TestUtil.readTinyV2(output);
        assertSrcNamespace("intermediary", tree);
        assertDstNamespace("named", tree, 0);
        // com/example/class_002 field_004 FIRST
        assertMapping(
            "FIRST",
            tree.getField("com/example/class_002", "field_004", "Lcom/example/class_002;"),
            "named"
        );
        // com/example/class_003$class_004 field_011 NORMAL
        assertMapping(
            "NORMAL",
            tree.getField("com/example/class_003$class_004", "field_011", "Lcom/example/class_003$class_004;"),
            "named"
        );

        final MappingTree.ClassMapping keep2 = tree.getClass("mappings/plugin/input/Keep$2");
        assertMapping("mappings/plugin/input/Keep$2", keep2, "named");
    }
}
